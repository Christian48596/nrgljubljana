(*
SYMTYPE=QSC3
Part of "NRG Ljubljana"
Rok Zitko, rok.zitko@ijs.si, 2015-2023
*)

(* CHANGE LOG *)
(* 29.10.2015 - first version *)
(* 4.11.2014 - new_f version *)

PREFIX = "qsc3";
fnprep[];

(* Make basis *)
myops = Take[allops, channels];
MyPrint["myops=", myops];

basis = Get["one_site_basis_new_f.data"];
basis = basis //. {
 f[CR, 0, s_] :> a[CR, s],
 f[CR, 1, s_] :> b[CR, s],
 f[CR, 2, s_] :> c[CR, s]
 };

MyPrint["basis=", basis];

mult[{q_, s_, p_}] := 2s+1;
basisprep[];

(* Problem dependent utility functions *)
fixstate[s_, sz_, state_] := fixspin[s, sz, state];

Invar[{diffq_, diffs_, diffp_}] := "Invar" <> tos3[diffq, 2diffs, diffp] <> ";"; 
InvarQN[{q_, s_, p_}] := "Invar" <> tos3[q, 2s+1, p] <> ";";

rule = { Piecewise[{{value_, cond_}}, 0] :> value }; (* new 2023 *)

simpl2[expr_] := Simplify[expr /. rule, S+Sz \[Element] Integers];

simpl4[expr_] := Simplify[expr, 2S \[Element] Integers && S>2];
simpl5[expr_] := (simpl4[expr //. Sz->S] /. r:Root[__] :> N[r]) (* Take maximal Sz!*)

(* Must be FullSimplify !!! *)
skpdtsimpl[expr_] := FullSimplify[expr, P \[Element] Integers];

koefstr1[koef_] := Module[{str=koefstr[koef]},
  str = StringReplace[str, "S"->"S(ss)"] 
];

koefstr2[koef_] := Module[{str=koefstr[koef]},
  (* recalcf[] *)
  str = StringReplace[str,"S"->"S(ssp)"] 
];

koefstr3[koef_] := Module[{str=koefstr[koef]},
  str = StringReplace[str,"S"->"S(ss1)"] 
];

(* Loop over all possible ways of combining states (cf. angular 
momentum addition rules, etc. *)

(* Args to newstates1[]: *)
(* qn: 1st argument to getexpr1[]: quantum numbers of the basis for the newly added site *)
(*    Defines the QN[] line in *-QN.dat *)
(* state: operator expression in terms of creation ops (a,b,c) *)

(* 2nd arg to newstates2[]: passed on to getexpr1[], defines the In[] line in *-In.dat, i.e.,
   the quantum number differences to determine the ancestors. *)

(* Consistency check: Number of states generated by the Do[] loop is related to the
   multiplicity as defined in mult[], i.e., this corresponds to the number of states
   in each irreducible representation for the dynamical group. *)

newstates1[qn:{q_, s_, p_}, state_] :=
  Do[newstates2[qn, {-q, diffs, Mod[-p, 3]}, state], {diffs, -s, s}];

(* Produce the expression for the new state *)
(* Q,S,P are the quantum numbers of the newly generated subspace. *)

getexpr1[qn:{q_, s_, p_}, d:{_, diffs_, _}, state_] := 
  Sum[ nc[coef @ simpl2 @ CG[{S+diffs, Sz-sz}, {s, sz}, {S, Sz}],
    dirpdt[{{Q-q, S+diffs, Mod[P-p,3]}, {Sz-sz}, r}, fixstate[s, sz, state]]], 
    {sz, -s, s}];

(* Matrix element for the HAMILTONIAN *)
CGmatrixel[qn1:{q1_, s1_, p1_}, diff1:{sz1_}, qn2:{q2_, s2_, p2_}, diff2:{sz2_}, 
  f[izn_, _, szn_]] := CG[{s2, sz2}, {1/2, spinofop[izn,szn]}, {s1, sz1}];

(* recalcf[] stuff; two arguments. called from makerecalcf[]. *)
irrule[opsz_, opp_] = {S -> S + opsz, Sz -> Sz + opsz, Q -> Q+1, P -> Mod[P+opp,3]};
ircg[opsz_, opp_] = CG[{S, Sz}, {1/2, opsz}, {S+opsz, Sz+opsz}];

outmake[{a_, b_, c_}] :=
  "Invar" <> toc3[a /. Q -> q1, 2(b-S)+ss1, c /. P->p1];

diffqn[qn1:{q1_, s1_, p1_}, qn2:{q2_, s2_, p2_}] := Module[{diff},
  diff = {q2-q1, s2-s1, Mod[p2-p1,3]}
];

CG2recalcop[qn1:{q1_, s1_, p1_}, diff1:{sz1_},
            qn2:{q2_, s2_, p2_}, diff2:{sz2_},
            {m_}] :=
  CG[{s2, sz2}, {m, sz1-sz2}, {s1, sz1}];
 
QNrecalcop[delta:{deltaq_, deltas_, deltap_}] := 
  (Qp = Q+deltaq; Sp = S+deltas; Pp = Mod[P+deltap,3]);

RULE1recalcop[{m_}] := {Sz -> S};
RULE2recalcop[{m_}] := {Q -> Qp, S -> Sp, Sz -> S-m, P -> Pp};

CG1recalcop[{m_}] := CG[{Sp, S-m}, {m, m}, {S, S}];

diffsD = {
  {{-1, 1/2, 0}, FNDOUBLET<>"p.dat"},
  {{-1, -1/2, 0}, FNDOUBLET<>"m.dat"}
};
  
diffsS = { {{0, 0, 0}, FNSINGLET<>".dat"} };

diffsT = { 
  {{0, 0, 0}, FNTRIPLET<>"s.dat"}, 
  {{0, 1, 0}, FNTRIPLET<>"p.dat"},
  {{0, -1, 0}, FNTRIPLET<>"m.dat"}
};

dorecalcfLOOP["QSC3", p_] := Module[{str, ch, op},
  For[ch = 0, ch < channels, ch++,
    op = ch2op[ch];
    MyPrint[1, "dorecalcfLOOP ch=", ch, " op=", op];
    makerecalcf[op[CR, UP], {1/2, p},  FNSPINUP   <> tos[p] <> "-" <> tos[op] ];
    makerecalcf[op[CR, DO], {-1/2, p}, FNSPINDOWN <> tos[p] <> "-" <> tos[op] ];
  ];
];

dorecalcfLOOP["QSC3"] := Module[{},
 dorecalcfLOOP["QSC3", 0];
(* dorecalcfLOOP["QSC3", 1];
 dorecalcfLOOP["QSC3", 2]; *)
];

SIMPLIFYNEW = True;

simplifynew[expr_] := FullSimplify[expr, 2S \[Element] Integers && S>=0];

matrixelsimpl[0] = 0;
matrixelsimpl[0.] = 0;
matrixelsimpl[0.+0.I] = 0;
matrixelsimpl[x_] := Chop[N[Simplify[x]]];

(* matrixop1 calls simpl2[] internally *)
matrixopdiagSUMCH[i_, i_] := matrixelsimpl @ simpl4[ matrixop1[i, i, number[a] + number[b] + number[c] ] ];

MATRIXNICHECKSYM[i1_, i2_] := Abs[ newqn[i1] [[1]] - newqn[i2] [[1]] ] != 1 ||
                              Abs[ newqn[i1] [[2]] - newqn[i2] [[2]] ] != 1/2;

doall[] := Module[{},
  donew[];

  ordering[a] = NONE;
  ordering[b] = NONE;
  ordering[c] = NONE;
  ordering[d] = NONE;
  ordering[e] = NONE;
  ordering[f] = NONE;
 
  dooffdiagNEW[];
  dodiagSUMCH[];
  dorecalcf["QSC3"];

  recalcop[{0}, diffsS];
  recalcop[{1/2}, diffsD];
  recalcop[{1}, diffsT];  
];
